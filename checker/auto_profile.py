import os
import subprocess
import glob
import shutil
import csv
import sys

# ================= Configuration =================
SIZES = [
    (100, 400),
    (2024, 3000),
]

P_VALUES = [
    "1.0",
    "2.0",
    "inf",
    "3.0"
]

DTYPES = [
    "float16",
    "float32"
]

DATA_RANGE = "S"
# ===========================================

def update_config(n, m, p, dtype):
    """Rewrite config.txt based on parameters"""
    config_content = f"""# Auto-generated by benchmark script
N={n}
M={m}
p={p}
data_type={dtype}
data_range={DATA_RANGE}
"""
    with open("config.txt", "w") as f:
        f.write(config_content)

def clean_logs():
    """Clean old OP* directories"""
    for item in glob.glob("OP*"):
        if os.path.isdir(item):
            shutil.rmtree(item)

def get_latest_profile_dir():
    """Get the latest generated OP directory"""
    dirs = glob.glob("OP*")
    if not dirs:
        return None
    # Sort by modification time, newest first
    dirs.sort(key=os.path.getmtime, reverse=True)
    return dirs[0]

def parse_duration(log_dir):
    """
    Simplified CSV parsing logic
    Target: Find 'Task Duration(us)' where 'Op Name' contains 'Pdist'
    """
    # 1. Find OpBasicInfo.csv (Recursive search)
    csv_path = None
    for root, dirs, files in os.walk(log_dir):
        if "OpBasicInfo.csv" in files:
            csv_path = os.path.join(root, "OpBasicInfo.csv")
            break
    
    if not csv_path:
        return "N/A (No CSV)"

    try:
        with open(csv_path, 'r', encoding='utf-8-sig') as f:
            reader = csv.DictReader(f)
            
            # Strip whitespace from headers
            if reader.fieldnames:
                reader.fieldnames = [name.strip() for name in reader.fieldnames]

            for row in reader:
                # Check Op Name
                op_name = row.get("Op Name", "")
                
                if "Pdist" in op_name:
                    return row.get("Task Duration(us)", "N/A")
            
            return "Not Found"
    except Exception as e:
        return f"Error: {e}"

def main():
    # Safety check: Prevent naming conflict with standard library 'profile'
    if os.path.basename(__file__) == "profile.py":
        print("‚ùå [Error] Please rename this script to 'benchmark.py'. Do NOT use 'profile.py'!")
        return

    if not os.path.exists("./run.sh"):
        print("‚ùå [Error] Please run this script inside the 'checker' directory.")
        return

    results = []
    total_tasks = len(SIZES) * len(P_VALUES) * len(DTYPES)
    
    print(f"üöÄ Starting automation test, total {total_tasks} cases...")
    print(f"{'No.':<5} | {'N':<6} | {'M':<6} | {'p':<5} | {'Type':<8} | {'Status'}")
    print("-" * 65)

    count = 0
    for (n, m) in SIZES:
        for dtype in DTYPES:
            for p in P_VALUES:
                count += 1
                prefix = f"{count}/{total_tasks}".ljust(5)
                print(f"{prefix} | {n:<6} | {m:<6} | {p:<5} | {dtype:<8} | Running...", end="\r")
                
                # 1. Clean & Config
                clean_logs()
                update_config(n, m, p, dtype)
                
                try:
                    # 2. Run msprof
                    # capture_output=True to hide stdout, check=True to raise exception on failure
                    subprocess.run(["msprof", "op", "./run.sh"], 
                                   capture_output=True, 
                                   check=True)

                    # 3. Parse Result
                    log_dir = get_latest_profile_dir()
                    if log_dir:
                        duration = parse_duration(log_dir)
                        status_str = f"{duration} us"
                    else:
                        status_str = "No Log Dir"

                except subprocess.CalledProcessError:
                    status_str = "Run Failed"
                except Exception as e:
                    status_str = "Error"

                # Print Result
                # Overwrite the "Running..." text
                print(f"{prefix} | {n:<6} | {m:<6} | {p:<5} | {dtype:<8} | {status_str:<15}")
                results.append((n, m, p, dtype, status_str))

    # ================= Output Final Report =================
    print("\n" + "="*20 + " Final Report " + "="*20)
    print(f"| {'N':<6} | {'M':<6} | {'p':<5} | {'Type':<8} | {'Duration (us)':<15} |")
    print(f"|{'-'*8}|{'-'*8}|{'-'*7}|{'-'*10}|{'-'*17}|")
    
    for row in results:
        print(f"| {row[0]:<6} | {row[1]:<6} | {row[2]:<5} | {row[3]:<8} | {row[4]:<15} |")
    
    # Save to file
    report_file = "performance_report.md"
    with open(report_file, "w") as f:
        f.write("# Pdist Operator Performance Report\n\n")
        f.write("| N | M | p | Type | Duration (us) |\n")
        f.write("|---|---|---|---|---|\n")
        for row in results:
            f.write(f"| {row[0]} | {row[1]} | {row[2]} | {row[3]} | {row[4]} |\n")

    print(f"\n‚úÖ Report saved to: {os.path.abspath(report_file)}")

if __name__ == "__main__":
    main()